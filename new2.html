<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>new运算符2</title>
		<script src="jquery-3.1.1.min.js"></script>
	</head>
	<body>
	</body>
</html>
<script>
	//　new是用来做继承的 

	//1.访问到wy构造函数里面的属性
	//2.访问到wy原型上的属性
	
	//解决问题　1 访问到wy构造函数里面的属性
//	function Parent(){
//		this.names = ['A','B'];
//	}
//	
//	function Child(){
//		Parent.call(this)
//	}
//	var child1 = new Child();
//	child1.names.push('C');
//	console.log(child1.names);


//	解决问题 2 访问到wy原型上的属性
// __proto__　用原型链来解决

	function WY(name,age){
		this.name = name;
		this.age = age;
		this.salary = '30k';

		return null;
    	
	}
	WY.prototype.ablility = 100;
	WY.prototype.sayYourName = function(){
		console.log('I am ' + this.name);
	}

	var person = Wnew(WY,'盖伦',25);
	
	console.log(person.name);
	console.log(person.age)
	console.log(person.salary)
	console.log(person.ablility)
	person.sayYourName();

	//网易的new 实现
   function Wnew(){
// 	var obj = {};//书面
//	var obj = new Object();//构造方式

//	var obj = Object.create(null);//创建一个空的对象,但是原型链的属性方法访问不到了
	
   	Constructor = [].shift.call(arguments);//获取arguments 第一个参数
   	var obj = Object.create(Constructor.prototype);

//	obj.__proto__ = Constructor.prototype;//把WY函数的原型赋值给obj
	var result = Constructor.apply(obj,arguments);//arguments里面有２个参数
	
	return typeof result === 'object' ? result || obj : obj;

   }
   
   // 五个步骤
   //1.创建一个空对象
   //2.获取arguments 第一个参数，arguments会少一个参数
   //3.将obj的原型链指向构造函数
   //4.使用apply改变函数this的指向　　指向于新对象　　　这样之后obj就可以访问到构造函数中的属性和方法
   //5.返回obj对象
   
	//对比之后
	//1.对象　　构造里面的属性不能使用，　只能使用返回的对象
	//2.基本类型　　跟不写没有区别
	
	
</script>